--------------------------------
CUESTIONES SOBRE FUNCIONALIDADES
--------------------------------
Pasarme informacion detallada de todos los socios(nro socio- nombre - direccion - telefono)

QUERES TENER REGISTROS DE COBRANZA PRECARGADOS DE OTROS ANIOS?

Solo se podran registrar cobranzas del anio actual (a menos que quieras que lo cambie)

queres que el bigote tenga acceso a la lista de registros? o que solo pueda cargar registros?

Hacer la funcionalidad estrictamente correcta para que el bigote no meta la pata, NO CARGAR 2 Registros el mismo mes, 
Si ya cargo registro como no pago que se pueda actualizar ese registro de ese mes concreto etc,

queres que agrege funcionalidad para los socios que pagan semestrales? que el bigote lo haga manual mes a mes

queres que el administrador o el bigote puedan modificar/eliminar/actualizar registros libremente?

TEMA HOSTTING la carga de datos demora por que es una subscripcion free

----------------------
RESTRICCIONES COBRADOR
----------------------

-SI EL BIGOTE SE EQUIVOCA Y HACE UN REGISTRO CONFIRMANDO EL PAGO DESPUES NO PUEDE MODIFCAR ESE REGISTRO PARA CAMBIAR EL ESTADO DEL PAGO!!!!!
-Si el registro ya esta pago ese mes el sistema no permite realizar accion y avisa al usuario que ya fue pagado
-El anio siempre es el actual
-Siempre debe seleccionar un mes y/o un socio para hacer un registro
-El socio debe estar preCargado en la base de datos
-No puede cargar 2 registro del mismo socio en el mismo mes, si actualizarlo para confirmar pago.
-Si hace un registro sin confirmacion de pago y luego quiere actualizar ese registro la unica opcion posible es que 
confirme el pago de ese registro, si esta accion es realizada el registro se actualiza y no se crea uno nuevo.

-------------------
RESTRICCIONES ADMIN
-------------------
-Queres algun tipo de filtro de busqueda adicional?
-Queres que se controlen los totales?
-Queres modificar Registros? cambiar estados de pago / fechas?
..................
.............
.........
....

/*-------------------------------------------------
  PROBLEMA DEL HOSTING "Demora en la carga de datos"
*-1 El problema del "Cold Start" (Arranque en fr√≠o)
En el plan gratuito de Render, los Web Services (tu backend) se suspenden despu√©s de 15 minutos de inactividad.

Qu√© sucede: Cuando entras a la vista de Administrador, el frontend hace un fetch, pero el backend est√° "dormido". Tarda entre 30 y 50 segundos
 en despertarse.

Soluci√≥n: Usar un servicio externo como Cron-job.org o UptimeRobot para que haga un "ping" a la URL de tu backend cada 14 minutos. Esto lo 
mantendr√° siempre despierto.

*/



























import { useEffect, useState } from "react";
import "./vistAdmin.css";

function Admin() {
  const [socios, setSocios] = useState([]);
  const [loading, setLoading] = useState(true);

  // Estados para los filtros
  const [filtroSocio, setFiltroSocio] = useState("");
  const [filtroMes, setFiltroMes] = useState("");
  const [filtroEstado, setFiltroEstado] = useState("todos"); // todos, pagados, pendientes

  useEffect(() => {
    fetch("https://socios-alasrojas-back.onrender.com/api/cobranzas")
      .then((res) => res.json())
      .then((data) => {
        const sociosMap = {};
        data.forEach((row) => {
          if (!sociosMap[row.nro_socio]) {
            sociosMap[row.nro_socio] = {
              nro_socio: row.nro_socio,
              nombre: row.nombre,
              cobranzas: [],
            };
          }
          sociosMap[row.nro_socio].cobranzas.push({
            id: row.id,
            mes: row.mes,
            anio: row.anio,
            pago: row.pago,
            fecha_pago: row.fecha_pago,
          });
        });
        setSocios(Object.values(sociosMap));
        setLoading(false);
      })
      .catch((err) => {
        console.error("Error cargando cobranzas:", err);
        setLoading(false);
      });
  }, []);

  // L√≥gica de filtrado
  const sociosFiltrados = socios.map(socio => {
    // Primero filtramos las cobranzas internas de cada socio
    const cobranzasFiltradas = socio.cobranzas.filter(c => {
      const coincideMes = filtroMes === "" || c.mes === parseInt(filtroMes);
      const coincideEstado =
        filtroEstado === "todos" ||
        (filtroEstado === "pagados" && c.pago) ||
        (filtroEstado === "pendientes" && !c.pago);

      return coincideMes && coincideEstado;
    });

    return { ...socio, cobranzasFiltradas };
  }).filter(socio => {
    // Luego filtramos si el socio coincide con el nro buscado 
    // y si tiene cobranzas que mostrar tras el filtro anterior
    const coincideNro = filtroSocio === "" || socio.nro_socio.toString().includes(filtroSocio);
    return coincideNro && socio.cobranzasFiltradas.length > 0;
  });

  if (loading) {
    return (
      <div className="admin"> 
        <div className="loading">
          <span className="spinner-reloj">‚åõ</span>
          <p style={{ color: "white" }}>Cargando Registros...</p>
        </div>
      </div>
    );
  } 

  return (
    <div className="admin">
      <h2 className="titulo">üìã Registros de Socios</h2>
      <br />
      {/* SECCI√ìN DE FILTROS */}
      <div className="filtros-container">
        <input
          type="text"
          placeholder="Buscar Nro Socio..."
          value={filtroSocio}
          onChange={(e) => setFiltroSocio(e.target.value)}
        />

        <select value={filtroMes} onChange={(e) => setFiltroMes(e.target.value)}>
          <option value="">Todos los Meses</option>
          <option value="1">Enero</option>
          <option value="2">Febrero</option>
          <option value="3">Marzo</option>
          <option value="4">Abril</option>
          <option value="5">Mayo</option>
          <option value="6">Junio</option>
          <option value="7">Julio</option>
          <option value="8">Agosto</option>
          <option value="9">Septiembre</option>
          <option value="10">Octubre</option>
          <option value="11">Noviembre</option>
          <option value="12">Diciembre</option>
        </select>

        <select value={filtroEstado} onChange={(e) => setFiltroEstado(e.target.value)}>
          <option value="todos">Todos los Registros</option>
          <option value="pagados">Solo Pagados ‚úÖ</option>
          <option value="pendientes">Solo Pendientes ‚ùå</option>
        </select>
      </div>

      {sociosFiltrados.length === 0 ? (
        <p style={{ color: "white" }}>No se encontraron resultados con los filtros aplicados.</p>
      ) : (
        sociosFiltrados.map((socio) => (
          <details key={socio.nro_socio} className="accordion" open>
            <summary>
              Socio {socio.nro_socio} - {socio.nombre}
              <span>({socio.cobranzasFiltradas.length} registros)</span>
            </summary>
            <ul>
              {socio.cobranzasFiltradas.map((c) => (
                <li key={c.id} className={c.pago ? "pago-si" : "pago-no"}>
                  <strong>Fecha {c.mes}/{c.anio}</strong> ‚Äî
                  {c.pago ? " ‚úÖ Pag√≥" : " ‚ùå Pendiente"}
                </li>
              ))}
            </ul>
          </details>
        ))
      )}
    </div>
  );
}

export default Admin;








import express from "express";
import pool from "../db.js";

const router = express.Router();

// 1. GET /api/cobranzas ‚Üí Listar cobranzas con datos del socio
router.get("/", async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT
        c.id, c.mes, c.anio, c.fecha_pago, c.pago,
        s.nro_socio, s.nombre
      FROM cobranzas c
      JOIN socios s ON s.nro_socio = c.nro_socio
      ORDER BY c.anio DESC, c.mes DESC
    `);
    res.json(result.rows);
  } catch (err) {
    console.error("Error obteniendo cobranzas:", err);
    res.status(500).json({ error: "Error al obtener cobranzas" });
  }
});

// 2. POST /api/cobranzas ‚Üí Registrar una nueva cobranza
router.post("/", async (req, res) => {
  const { nro_socio, mes, anio, pago, fecha_pago } = req.body;

  if (!nro_socio || !mes || !anio) {
    return res.status(400).json({ error: "Faltan datos obligatorios (socio, mes o a√±o)" });
  }

  try {
    const result = await pool.query(
      `INSERT INTO cobranzas (nro_socio, mes, anio, pago, fecha_pago) 
       VALUES ($1, $2, $3, $4, $5) 
       RETURNING *`,
      [nro_socio, mes, anio, pago, fecha_pago]
    );

    res.status(201).json({
      message: "Cobranza registrada con √©xito",
      data: result.rows[0]
    });
  } catch (err) {
    console.error("Error al insertar cobranza:", err);

    if (err.code === '23503') {
      return res.status(400).json({ error: "El n√∫mero de socio no existe." });
    }
    if (err.code === '23505') {
      return res.status(400).json({ error: "Ya existe un registro para este socio en este mes/a√±o." });
    }
    if (err.code === '23514') {
      return res.status(400).json({ error: "Si marca 'Pag√≥', debe incluir la fecha de pago." });
    }

    res.status(500).json({ error: "Error interno del servidor al guardar." });
  }
});

// 3. PUT /api/cobranzas/:id ‚Üí Actualizar una cobranza existente
router.put("/:id", async (req, res) => {
  const { id } = req.params;
  const { pago, fecha_pago } = req.body;

  try {
    const result = await pool.query(
      "UPDATE cobranzas SET pago = $1, fecha_pago = $2 WHERE id = $3 RETURNING *",
      [pago, fecha_pago, id]
    );

    if (result.rowCount === 0) {
      return res.status(404).json({ error: "Registro no encontrado" });
    }

    res.json({
      message: "Registro actualizado",
      data: result.rows[0]
    });
  } catch (err) {
    console.error("Error al actualizar cobranza:", err);
    res.status(500).json({ error: "Error al actualizar" });
  }
});

export default router;







